<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Juego de la Vida — Simple (Blanco y Negro)</title>
<style>
  :root{
    --bg:#ffffff;       /* color fondo (rejilla) */
    --cell:#000000;     /* color celda viva */
    --grid:#ffffff;     /* color líneas de rejilla */
    --ui-bg: #111;      /* panel UI background */
    --ui-fg: #fff;
  }

  html,body{
    height:100%;
    margin:0;
    font-family:system-ui,Segoe UI,Roboto,Arial;
    background:linear-gradient(#f6f6f6,#eaeaea);
    display:flex;
    align-items:center;
    justify-content:center;
    gap:20px;
    padding:20px;
    box-sizing:border-box;
  }

  .container{
    display:flex;
    gap:18px;
    align-items:flex-start;
  }

  canvas{
    background:var(--bg);
    image-rendering:pixelated; /* bordes nítidos */
    box-shadow:0 6px 18px rgba(0,0,0,.12);
    border-radius:6px;
    cursor:crosshair;
  }

  .controls{
    width:260px;
    background:var(--ui-bg);
    color:var(--ui-fg);
    padding:12px;
    border-radius:8px;
    box-shadow:0 6px 18px rgba(0,0,0,.12);
    display:flex;
    flex-direction:column;
    gap:10px;
  }

  .controls h3{ margin:0 0 6px 0; font-size:16px; }
  .row{ display:flex; gap:8px; align-items:center; }
  button, input[type=range], select { font:inherit; }
  button{
    flex:1;
    padding:8px 10px;
    border-radius:6px;
    border:0;
    background:#2b2b2b;
    color:white;
    cursor:pointer;
  }
  button.secondary{ background:#444; }
  .small{ padding:6px 8px; font-size:13px; }
  label{ font-size:13px; }
  .muted{ font-size:12px; color:#ddd; }
  .kbd{ background:#00000022; padding:6px 8px; border-radius:6px; font-size:12px; }
  .footer{ font-size:12px; color:#ddd; margin-top:6px; }
</style>
</head>
<body>
  <div class="container">
    <canvas id="board"></canvas>

    <div class="controls" aria-label="Controles Juego de la Vida">
      <h3>Juego de la Vida — B/N</h3>

      <div class="row">
        <button id="startStop" class="small">Iniciar</button>
        <button id="step" class="small secondary">Paso</button>
      </div>

      <div class="row">
        <button id="clear" class="small secondary">Limpiar</button>
        <button id="random" class="small">Aleatorio</button>
      </div>

      <div>
        <label>Velocidad: <span id="speedLabel">8</span> gen/s</label>
        <input id="speed" type="range" min="1" max="30" value="8" />
      </div>

      <div>
        <label>Cell size (px):</label>
        <select id="cellSize">
          <option value="8">8 px</option>
          <option value="10" selected>10 px</option>
          <option value="12">12 px</option>
          <option value="16">16 px</option>
        </select>
      </div>

      <div>
        <label><input type="checkbox" id="wrap"> Rejilla toroidal (bordes conectados)</label>
      </div>

      <div class="row">
        <div class="muted">Atajos:</div>
        <div class="kbd">Espacio = Iniciar/Pausar</div>
      </div>
      <div class="footer">
        Haz clic para alternar células. Arrastra con el botón izquierdo para dibujar.
      </div>
    </div>
  </div>

<script>
/*
  Juego de la Vida — Vanilla JS
  - Blanco (fondo/rejilla) y negro (células vivas)
  - Click para alternar, arrastrar para dibujar
  - Opciones: tamaño de celda, velocidad, aleatorio, limpiar, paso, wrap
*/

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

let cellSize = parseInt(document.getElementById('cellSize').value,10);
let rows, cols;
let grid = [];
let running = false;
let timer = null;
let gensPerSecond = parseInt(document.getElementById('speed').value,10);
let wrap = document.getElementById('wrap').checked;

// UI elements
const startStopBtn = document.getElementById('startStop');
const stepBtn = document.getElementById('step');
const clearBtn = document.getElementById('clear');
const randomBtn = document.getElementById('random');
const speedInput = document.getElementById('speed');
const speedLabel = document.getElementById('speedLabel');
const cellSizeSelect = document.getElementById('cellSize');

function resizeToWindow(){
  // canvas keeps a margin; we'll make a grid that fits nicely
  const maxWidth = Math.min(window.innerWidth - 340, 900);
  const maxHeight = Math.min(window.innerHeight - 80, 900);
  // compute cols/rows based on cellSize
  cols = Math.max(10, Math.floor(maxWidth / cellSize));
  rows = Math.max(10, Math.floor(maxHeight / cellSize));
  canvas.width = cols * cellSize;
  canvas.height = rows * cellSize;
  ensureGridSize();
  draw();
}

function ensureGridSize(){
  // initialize grid if needed or resize keeping content (centered)
  const newGrid = Array.from({length: rows}, () => Array(cols).fill(0));
  if (grid.length){
    // copy overlap
    for (let r=0; r<Math.min(rows, grid.length); r++){
      for (let c=0; c<Math.min(cols, grid[0].length); c++){
        newGrid[r][c] = grid[r][c];
      }
    }
  }
  grid = newGrid;
}

function draw(){
  // background (white grid will be drawn as lines on top)
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#fff';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw cells (black squares)
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cell') || '#000';
  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      if (grid[r][c]){
        ctx.fillRect(c*cellSize, r*cellSize, cellSize, cellSize);
      }
    }
  }

  // draw grid lines (white thin)
  ctx.beginPath();
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid') || '#fff';
  ctx.lineWidth = 1;
  // vertical lines
  for (let c=0;c<=cols;c++){
    const x = c*cellSize + 0.5; // crisper lines
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
  }
  // horizontal lines
  for (let r=0;r<=rows;r++){
    const y = r*cellSize + 0.5;
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
  }
  ctx.stroke();
}

function step(){
  const next = Array.from({length: rows}, () => Array(cols).fill(0));
  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      const alive = grid[r][c];
      let n = neighbors(r,c);
      if (alive){
        next[r][c] = (n===2 || n===3) ? 1 : 0;
      } else {
        next[r][c] = (n===3) ? 1 : 0;
      }
    }
  }
  grid = next;
  draw();
}

function neighbors(r,c){
  let count = 0;
  for (let dr=-1; dr<=1; dr++){
    for (let dc=-1; dc<=1; dc++){
      if (dr===0 && dc===0) continue;
      let rr = r+dr, cc = c+dc;
      if (wrap){
        rr = (rr + rows) % rows;
        cc = (cc + cols) % cols;
      } else {
        if (rr < 0 || rr >= rows || cc < 0 || cc >= cols) continue;
      }
      if (grid[rr] && grid[rr][cc]) count++;
    }
  }
  return count;
}

function play(){
  if (running) return;
  running = true;
  startStopBtn.textContent = 'Pausar';
  schedule();
}

function pause(){
  running = false;
  startStopBtn.textContent = 'Iniciar';
  if (timer) { clearInterval(timer); timer = null; }
}

function schedule(){
  if (timer) clearInterval(timer);
  const interval = 1000 / gensPerSecond;
  timer = setInterval(()=> step(), interval);
}

startStopBtn.addEventListener('click', () => {
  running ? pause() : play();
});

stepBtn.addEventListener('click', () => {
  if (!running) step();
});

clearBtn.addEventListener('click', () => {
  grid = Array.from({length: rows}, () => Array(cols).fill(0));
  draw();
});

randomBtn.addEventListener('click', () => {
  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      grid[r][c] = Math.random() < 0.35 ? 1 : 0;
    }
  }
  draw();
});

speedInput.addEventListener('input', (e) => {
  gensPerSecond = Number(e.target.value);
  speedLabel.textContent = gensPerSecond;
  if (running) schedule();
});

cellSizeSelect.addEventListener('change', (e) => {
  cellSize = Number(e.target.value);
  resizeToWindow();
});

document.getElementById('wrap').addEventListener('change', (e)=> {
  wrap = e.target.checked;
});

window.addEventListener('resize', () => {
  // debounce small resize events
  clearTimeout(window._resizeTimer);
  window._resizeTimer = setTimeout(resizeToWindow, 120);
});

// ----- mouse interaction for toggling/painting -----
let isMouseDown = false;
let paintValue = 1; // when starting drag, determine if we're drawing or erasing

canvas.addEventListener('mousedown', (e) => {
  isMouseDown = true;
  const {row,col} = posFromEvent(e);
  if (row>=0 && col>=0 && row<rows && col<cols){
    paintValue = grid[row][col] ? 0 : 1;
    grid[row][col] = paintValue;
    draw();
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (!isMouseDown) return;
  const {row,col} = posFromEvent(e);
  if (row>=0 && col>=0 && row<rows && col<cols){
    grid[row][col] = paintValue;
    draw();
  }
});

window.addEventListener('mouseup', () => isMouseDown = false);

function posFromEvent(e){
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const col = Math.floor(x / cellSize);
  const row = Math.floor(y / cellSize);
  return {row, col};
}

// keyboard shortcuts
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space') { e.preventDefault(); running ? pause() : play(); }
  if (e.key === 'c' || e.key === 'C') { clearBtn.click(); }
  if (e.key === 'r' || e.key === 'R') { randomBtn.click(); }
  if (e.key === 'ArrowRight') { if (!running) step(); }
});

// initialize
resizeToWindow();
speedLabel.textContent = gensPerSecond;

// optional: seed a small glider for demo
(function seedDemo(){
  const midR = Math.floor(rows/2), midC = Math.floor(cols/2);
  grid[midR][midC+1] = 1;
  grid[midR+1][midC+2] = 1;
  grid[midR+2][midC] = 1;
  grid[midR+2][midC+1] = 1;
  grid[midR+2][midC+2] = 1;
  draw();
})();
</script>
</body>
</html>
