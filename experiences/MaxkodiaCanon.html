<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Maxkodia Crater Exploration</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      background: white;
    }
    canvas { 
      display: block; 
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: white;
      font-family: Arial, sans-serif;
      pointer-events: none;
      text-shadow: 1px 1px 2px black;
    }
  </style>
</head>
<body>
  <div id="info">Haz clic y arrastra para mover la cámara · Rueda del ratón para hacer zoom</div>
  
  <!-- Three.js y complementos -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  
  <script>
    // Variables globales
    let scene, camera, renderer, controls, terrain, player;
    let clock = new THREE.Clock();
    
    init();
    animate();

    function init() {
      // Escena
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff); // Fondo blanco
      
      // Cámara
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 50, 50);
      
      // Renderizador
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Mejor calidad de sombras
      
      // Sol (luz direccional principal)
      const sunLight = new THREE.DirectionalLight(0xfff4e6, 1);
      sunLight.position.set(100, 200, 100);
      sunLight.castShadow = true;
      
      // Configurar sombras del sol
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      sunLight.shadow.camera.near = 0.5;
      sunLight.shadow.camera.far = 500;
      sunLight.shadow.camera.left = -100;
      sunLight.shadow.camera.right = 100;
      sunLight.shadow.camera.top = 100;
      sunLight.shadow.camera.bottom = -100;
      sunLight.shadow.bias = -0.0001;
      
      scene.add(sunLight);
      
      // Luz de relleno suave desde abajo
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
      fillLight.position.set(-50, -100, -50);
      scene.add(fillLight);
      document.body.appendChild(renderer.domElement);
      
      // Controles orbitales
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 5;
      controls.maxDistance = 500;
      controls.maxPolarAngle = Math.PI / 2;
      
      // Luz ambiental
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      // Luz direccional
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 200, 100);
      dirLight.castShadow = true;
      dirLight.shadow.camera.top = 180;
      dirLight.shadow.camera.bottom = -100;
      dirLight.shadow.camera.left = -120;
      dirLight.shadow.camera.right = 120;
      scene.add(dirLight);
      
      // Cargar terreno
      const loader = new THREE.GLTFLoader();
      loader.load(
        '../assets/models/max_crater.glb',
        function(gltf) {
          terrain = gltf.scene;
          terrain.traverse(function(node) {
            if (node.isMesh) {
              node.castShadow = true;
              node.receiveShadow = true;
            }
          });
          scene.add(terrain);
          
          // Ajustar la cámara al tamaño del terreno
          const box = new THREE.Box3().setFromObject(terrain);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          
          // Crear jugador (esfera)
          createPlayer(center);
        },
        undefined,
        function(error) {
          console.error('Error al cargar el modelo:', error);
        }
      );
      
      // Manejo de redimensión de ventana
      window.addEventListener('resize', onWindowResize, false);
    }
    
    function createPlayer(position) {
      const geometry = new THREE.SphereGeometry(1, 32, 32);
      const material = new THREE.MeshPhongMaterial({ 
        color: 0x00ff00,
        shininess: 100
      });
      
      player = new THREE.Mesh(geometry, material);
      player.position.copy(position);
      player.position.y += 10; // Posicionar por encima del terreno
      player.castShadow = true;
      scene.add(player);
      
      // Hacer que la cámara siga al jugador
      controls.target.copy(player.position);
      camera.lookAt(player.position);
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      
      // Actualizar controles
      if (controls) controls.update(delta);
      
      // Actualizar lógica del jugador aquí si es necesario
      
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
